<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Narrative Engine - Play</title>
    
    <!-- HTMX for server interactions -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/htmx.org/dist/ext/ws.js"></script>
    
    <!-- Alpine.js for reactive UI -->
    <script defer src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom scrollbar */
        .narrative-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .narrative-scroll::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .narrative-scroll::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 3px;
        }
        
        /* Typing animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body class="h-full bg-gray-900 text-gray-100" x-data="gameApp()" x-init="init()">
    
    <!-- Character Creation Screen -->
    <div x-show="gameState === 'character'" class="h-full flex items-center justify-center p-8">
        <div class="max-w-2xl w-full bg-gray-800 rounded-lg shadow-xl p-8">
            <h1 class="text-3xl font-bold mb-8 text-center bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                Begin Your Adventure
            </h1>
            
            <!-- Link to Session Manager -->
            <div class="mb-6 text-center">
                <a href="/sessions" class="inline-block px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm transition-colors">
                    üìö View Saved Adventures
                </a>
            </div>
            
            <!-- Saved Characters -->
            <div x-show="savedCharacters.length > 0" class="mb-6">
                <h3 class="text-lg font-semibold mb-3 text-amber-200">Quick Load Character</h3>
                <div class="grid gap-2 max-h-40 overflow-y-auto">
                    <template x-for="char in savedCharacters" :key="char.name">
                        <button @click="loadSavedCharacter(char)"
                                class="text-left p-3 bg-gray-700 rounded hover:bg-gray-600 transition-colors">
                            <div class="font-semibold text-purple-300" x-text="char.name"></div>
                            <div class="text-sm text-gray-400" x-text="char.description.substring(0, 80) + '...'"></div>
                        </button>
                    </template>
                </div>
            </div>
            
            <!-- Character Form -->
            <div class="space-y-6">
                <div>
                    <label class="block text-sm font-medium mb-2">Character Name</label>
                    <input 
                        type="text" 
                        x-model="character.name"
                        class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-purple-500"
                        placeholder="Enter your character's name"
                    >
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-2">Character Description</label>
                    <textarea 
                        x-model="character.description"
                        class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-purple-500 h-24"
                        placeholder="Describe your character's appearance, background, personality..."
                    ></textarea>
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-2">Choose Your World</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <template x-for="template in worldTemplates" :key="template.id">
                            <button 
                                @click="selectWorld(template.id)"
                                :class="character.worldType === template.id ? 'ring-2 ring-purple-500' : ''"
                                class="p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors text-left"
                            >
                                <div class="font-semibold">
                                    <span x-text="template.icon || 'üè∞'"></span>
                                    <span x-text="template.name"></span>
                                </div>
                                <div class="text-sm text-gray-400 mt-1" x-text="template.description"></div>
                                <div x-show="template.mood" class="text-xs text-purple-400 mt-2" x-text="'Mood: ' + template.mood"></div>
                            </button>
                        </template>
                    </div>
                </div>
                
                <!-- Custom World Prompt -->
                <div x-show="character.worldType === 'custom'" class="space-y-2">
                    <label class="block text-sm font-medium">Describe Your World</label>
                    <textarea 
                        x-model="character.customPrompt"
                        class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:border-purple-500 h-24"
                        placeholder="Describe the setting, atmosphere, and any NPCs present..."
                    ></textarea>
                </div>
                
                <div class="flex gap-4">
                    <button 
                        @click="saveCharacter()"
                        :disabled="!character.name || !character.description"
                        class="px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded-lg font-semibold transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        title="Save this character for quick loading later"
                    >
                        üíæ Save
                    </button>
                    <button 
                        @click="startGame()"
                        :disabled="!character.name || !character.worldType"
                        class="flex-1 py-3 bg-gradient-to-r from-purple-600 to-pink-600 rounded-lg font-semibold hover:from-purple-700 hover:to-pink-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        Begin Adventure
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div x-show="gameState === 'loading'" class="h-full flex items-center justify-center">
        <div class="text-center">
            <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
            <p class="mt-4 text-gray-400">Creating your world...</p>
        </div>
    </div>
    
    <!-- Game Screen -->
    <div x-show="gameState === 'playing'" class="h-full flex flex-col">
        
        <!-- Header -->
        <header class="bg-gray-800 border-b border-gray-700 px-6 py-3 flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <h1 class="text-xl font-bold">Narrative Engine</h1>
                <span class="text-gray-400">|</span>
                <span class="text-purple-400" x-text="character.name"></span>
            </div>
            <div class="flex items-center space-x-4">
                <!-- Performance Indicator -->
                <div class="flex items-center space-x-2 text-xs">
                    <div class="flex items-center space-x-1">
                        <div class="w-2 h-2 rounded-full" 
                             :class="websocket && websocket.readyState === 1 ? 'bg-green-500' : 'bg-red-500'"></div>
                        <span class="text-gray-400">
                            <span x-show="websocket && websocket.readyState === 1">Connected</span>
                            <span x-show="!websocket || websocket.readyState !== 1">Offline</span>
                        </span>
                    </div>
                    <span x-show="lastResponseTime > 0" class="text-gray-500">
                        ‚Ä¢ Avg: <span x-text="lastResponseTime.toFixed(1)"></span>s
                    </span>
                </div>
                <span class="text-sm text-gray-400" x-text="currentLocation"></span>
                <button @click="saveGame()" class="px-3 py-1 bg-gray-700 rounded hover:bg-gray-600">
                    üíæ Save
                </button>
            </div>
        </header>
        
        <!-- Main Game Area -->
        <div class="flex-1 flex overflow-hidden">
            
            <!-- Narrative Panel -->
            <div class="flex-1 flex flex-col bg-gray-850">
                
                <!-- Narrative Display -->
                <div class="flex-1 overflow-y-auto narrative-scroll p-6" id="narrative-container">
                    <div class="max-w-4xl mx-auto space-y-4">
                        
                        <!-- Initial Scene -->
                        <div x-show="initialNarrative" class="fade-in">
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700">
                                <div class="text-sm text-purple-400 mb-2">üìç Scene Established</div>
                                <div x-html="formatNarrative(initialNarrative)"></div>
                            </div>
                        </div>
                        
                        <!-- Narrative Entries -->
                        <template x-for="entry in narrativeHistory" :key="entry.id">
                            <div class="fade-in space-y-3">
                                
                                <!-- Player Action -->
                                <div x-show="entry.action" class="flex justify-end">
                                    <div class="bg-purple-900/30 rounded-lg p-3 max-w-lg border border-purple-700/50">
                                        <div class="text-xs text-purple-400 mb-1">You:</div>
                                        <div x-text="entry.action"></div>
                                    </div>
                                </div>
                                
                                <!-- Narrative Response -->
                                <div x-show="entry.narrative" class="bg-gray-800 rounded-lg p-4 border border-gray-700">
                                    <div x-html="formatNarrative(entry.narrative)"></div>
                                </div>
                                
                                <!-- Dialogue -->
                                <div x-show="entry.dialogue && entry.dialogue.length > 0" class="space-y-2">
                                    <template x-for="(dialogue, index) in (entry.dialogue || [])" :key="index">
                                        <div class="ml-4">
                                            <div :class="dialogue.speaker === character.name ? 'text-purple-300' : 'text-blue-300'">
                                                <span class="font-semibold" x-text="dialogue.speaker + ':'"></span>
                                                <span x-text="dialogue.dialogue"></span>
                                                <span x-show="dialogue.action" class="text-purple-400 italic ml-2">
                                                    *<span x-text="dialogue.action"></span>*
                                                </span>
                                            </div>
                                            <div x-show="dialogue.tone" class="text-xs text-gray-500 italic ml-4" x-text="'(' + dialogue.tone + ')'"></div>
                                        </div>
                                    </template>
                                </div>
                                
                                <!-- Debug: Show raw dialogue data (hidden by default) -->
                                <div x-show="false" class="mt-2 p-2 bg-red-900 rounded text-xs">
                                    <div>Dialogue count: <span x-text="entry.dialogue ? entry.dialogue.length : 0"></span></div>
                                    <pre x-text="JSON.stringify(entry.dialogue, null, 2)"></pre>
                                </div>
                                
                            </div>
                        </template>
                        
                        <!-- Typing Indicator with Timer -->
                        <div x-show="isProcessing" class="flex items-center justify-between bg-gray-800 rounded-lg p-3 border border-gray-700">
                            <div class="flex items-center space-x-2">
                                <div class="flex space-x-1">
                                    <div class="w-2 h-2 bg-purple-500 rounded-full animate-bounce" style="animation-delay: 0ms"></div>
                                    <div class="w-2 h-2 bg-purple-500 rounded-full animate-bounce" style="animation-delay: 150ms"></div>
                                    <div class="w-2 h-2 bg-purple-500 rounded-full animate-bounce" style="animation-delay: 300ms"></div>
                                </div>
                                <span class="text-sm">The world responds...</span>
                            </div>
                            <div class="flex items-center space-x-3 text-sm">
                                <span class="text-gray-400" x-text="processingTime + 's'"></span>
                                <span x-show="processingRetries > 0" class="text-amber-400">
                                    (Retry <span x-text="processingRetries"></span>/3)
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                <!-- Input Area -->
                <div class="border-t border-gray-700 p-4">
                    <div class="max-w-4xl mx-auto">
                        <form @submit.prevent="sendAction()" class="flex space-x-3">
                            <input 
                                type="text"
                                x-model="currentAction"
                                :disabled="isProcessing"
                                class="flex-1 px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg focus:outline-none focus:border-purple-500 disabled:opacity-50"
                                placeholder="What do you do? (Type naturally or use /help for commands)"
                            >
                            <button 
                                type="submit"
                                :disabled="!currentAction || isProcessing"
                                class="px-6 py-2 bg-purple-600 rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                            >
                                Send
                            </button>
                        </form>
                        <div class="mt-2 text-xs text-gray-500">
                            Commands: look, inventory, stats, save, help, quit
                        </div>
                    </div>
                </div>
                
            </div>
            
            <!-- Side Panel -->
            <div class="w-80 bg-gray-800 border-l border-gray-700 p-4 overflow-y-auto">
                
                <!-- Location Info -->
                <div class="mb-6">
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">üìç LOCATION</h3>
                    <div class="bg-gray-700/50 rounded p-3">
                        <div class="font-medium" x-text="currentLocation"></div>
                        <div class="text-sm text-gray-400 mt-1" x-text="locationMood"></div>
                    </div>
                </div>
                
                <!-- World State -->
                <div class="mb-6" x-show="worldState && Object.keys(worldState).length > 0">
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">üåç WORLD</h3>
                    <div class="bg-gray-700/50 rounded p-3 space-y-1 text-xs">
                        <div x-show="worldState.time_of_day" class="text-gray-300">
                            <span>üïê </span><span x-text="worldState.time_of_day || 'Unknown'"></span>
                        </div>
                        <div x-show="worldState.weather" class="text-gray-300">
                            <span>üå§Ô∏è </span><span x-text="worldState.weather || 'Clear'"></span>
                        </div>
                        <div x-show="worldState.season" class="text-gray-300">
                            <span>üçÇ </span><span x-text="worldState.season || 'Unknown'"></span>
                        </div>
                        <div x-show="worldState.ambient_activity && worldState.ambient_activity.length > 0" class="text-amber-400 mt-2">
                            <div class="font-semibold mb-1">Recent Activity:</div>
                            <template x-for="activity in (worldState.ambient_activity || []).slice(-2)">
                                <div class="text-gray-400">‚Ä¢ <span x-text="activity"></span></div>
                            </template>
                        </div>
                        <div x-show="worldState.recent_news && worldState.recent_news.length > 0" class="text-purple-400 mt-2">
                            <div class="font-semibold mb-1">Latest News:</div>
                            <template x-for="news in (worldState.recent_news || []).slice(-2)">
                                <div class="text-gray-400">‚Ä¢ <span x-text="news"></span></div>
                            </template>
                        </div>
                    </div>
                </div>
                
                <!-- Characters Present -->
                <div class="mb-6">
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">üë• PRESENT</h3>
                    <div class="space-y-2">
                        <template x-for="char in presentCharacters" :key="char.name">
                            <div class="bg-gray-700/50 rounded p-3">
                                <!-- Name and Position -->
                                <div class="flex justify-between items-start mb-1">
                                    <div class="font-medium" :class="char.is_player ? 'text-purple-400' : 'text-gray-200'" x-text="char.name"></div>
                                    <div x-show="char.relationship" class="text-xs">
                                        <span x-show="char.relationship === 'friendly'" class="text-green-400">‚ù§Ô∏è</span>
                                        <span x-show="char.relationship === 'neutral'" class="text-gray-400">üíõ</span>
                                        <span x-show="char.relationship === 'hostile'" class="text-red-400">üíî</span>
                                        <span x-show="char.relationship === 'romantic'" class="text-pink-400">üíï</span>
                                    </div>
                                </div>
                                <div class="text-xs text-gray-400 mb-1" x-text="'üìç ' + (char.position || 'present')"></div>
                                
                                <!-- Emotional State -->
                                <div x-show="char.emotional_state" class="text-xs text-gray-400">
                                    <span x-text="'üí≠ ' + (char.emotional_state || 'calm')"></span>
                                </div>
                                
                                <!-- Clothing State -->
                                <div x-show="char.clothing" class="text-xs text-gray-400 mt-1">
                                    <span x-show="char.clothing === 'dressed'" class="text-gray-400">üëî Dressed</span>
                                    <span x-show="char.clothing === 'partial'" class="text-amber-400">üëï Partial</span>
                                    <span x-show="char.clothing === 'underwear'" class="text-orange-400">ü©± Underwear</span>
                                    <span x-show="char.clothing === 'towel'" class="text-blue-400">üõÅ Towel</span>
                                    <span x-show="char.clothing === 'naked'" class="text-red-400">üîû Nude</span>
                                    <span x-show="!char.clothing" class="text-gray-500">üëî Unknown</span>
                                </div>
                                
                                <!-- Memory Indicator -->
                                <div x-show="char.memory_count > 0" class="text-xs text-purple-400 mt-1">
                                    <span>üß† Remembers <span x-text="char.memory_count"></span> interactions</span>
                                    <div x-show="char.last_memory" class="text-gray-500">
                                        <span x-text="'Last: ' + char.last_memory"></span>
                                    </div>
                                </div>
                                
                                <!-- Gossip Indicator -->
                                <div x-show="char.knows_gossip" class="text-xs text-amber-400 mt-1">
                                    <span>üí¨ Knows recent gossip</span>
                                    <div x-show="char.recent_gossip && char.recent_gossip.length > 0" class="text-gray-500 mt-1">
                                        <template x-for="gossip in (char.recent_gossip || []).slice(0, 2)">
                                            <div class="truncate" x-text="'‚Ä¢ ' + gossip.substring(0, 50) + '...'"></div>
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- World Knowledge -->
                                <div x-show="char.world_knowledge && char.world_knowledge.length > 0" class="text-xs text-blue-400 mt-1">
                                    <span>üåç Aware of events</span>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
                
                <!-- Scene Info -->
                <div class="mb-6">
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">üé≠ SCENE</h3>
                    <div class="bg-gray-700/50 rounded p-3">
                        <div class="flex justify-between items-center">
                            <span class="text-sm">Tension</span>
                            <span class="text-sm font-medium" x-text="tensionLevel + '/100'"></span>
                        </div>
                        <div class="mt-2 bg-gray-600 rounded-full h-2">
                            <div class="bg-gradient-to-r from-green-500 to-red-500 h-2 rounded-full transition-all duration-500" 
                                 :style="'width: ' + tensionLevel + '%'"></div>
                        </div>
                        <!-- Response Time -->
                        <div x-show="lastResponseTime > 0" class="mt-3 pt-3 border-t border-gray-600">
                            <div class="flex justify-between items-center text-xs">
                                <span class="text-gray-400">Last Response</span>
                                <span class="font-mono" 
                                      :class="lastResponseTime < 5 ? 'text-green-400' : (lastResponseTime < 15 ? 'text-yellow-400' : 'text-red-400')" 
                                      x-text="lastResponseTime.toFixed(1) + 's'"></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Actions -->
                <div>
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">‚ö° QUICK ACTIONS</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button @click="quickAction('look around')" class="px-3 py-2 bg-gray-700 rounded text-sm hover:bg-gray-600">
                            üëÅÔ∏è Look
                        </button>
                        <button @click="quickAction('inventory')" class="px-3 py-2 bg-gray-700 rounded text-sm hover:bg-gray-600">
                            üéí Inventory
                        </button>
                        <button @click="quickAction('stats')" class="px-3 py-2 bg-gray-700 rounded text-sm hover:bg-gray-600">
                            üìä Stats
                        </button>
                        <button @click="quickAction('help')" class="px-3 py-2 bg-gray-700 rounded text-sm hover:bg-gray-600">
                            ‚ùì Help
                        </button>
                    </div>
                    
                    <!-- Debug: Test dialogue display -->
                    <button @click="testDialogue()" class="mt-2 w-full px-3 py-2 bg-purple-700 rounded text-sm hover:bg-purple-600">
                        üß™ Test Dialogue Display
                    </button>
                </div>
                
            </div>
            
        </div>
        
    </div>
    
    <script>
        function gameApp() {
            return {
                // Game states: 'character', 'loading', 'playing', 'resuming'
                gameState: 'character',
                
                // Character creation
                character: {
                    name: '',
                    description: '',
                    worldType: 'fantasy_tavern',
                    customPrompt: ''
                },
                
                // Saved characters
                savedCharacters: [],
                
                // World templates
                worldTemplates: [],
                
                // Game session
                sessionId: null,
                websocket: null,
                hasExistingSession: false,
                
                // Game data
                currentLocation: 'Unknown',
                locationMood: '',
                presentCharacters: [],
                tensionLevel: 0,
                worldState: {},
                
                // Narrative
                initialNarrative: '',
                narrativeHistory: [], // Always an array, never null/undefined
                currentAction: '',
                isProcessing: false,
                processingTime: 0,
                processingTimer: null,
                processingRetries: 0,
                lastResponseTime: 0,
                
                // Initialize and check for existing session
                async init() {
                    // Check if we're coming from the session selector
                    const fromSelector = localStorage.getItem('narrative_resume_from_selection');
                    if (fromSelector === 'true') {
                        localStorage.removeItem('narrative_resume_from_selection');
                        // Resume directly without prompt
                        const savedSessionId = localStorage.getItem('narrative_session_id');
                        if (savedSessionId) {
                            this.sessionId = savedSessionId;
                            await this.resumeSession();
                            return;
                        }
                    }
                    
                    // If not from selector, always start fresh
                    // User can go to /sessions to resume a saved game
                    this.gameState = 'character';
                    
                    // Load saved characters
                    await this.loadSavedCharacters();
                    
                    // Load world templates
                    await this.loadWorldTemplates();
                },
                
                async loadWorldTemplates() {
                    try {
                        const response = await fetch('/api/templates');
                        if (response.ok) {
                            this.worldTemplates = await response.json();
                            console.log('Loaded world templates:', this.worldTemplates);
                        }
                    } catch (error) {
                        console.error('Failed to load world templates:', error);
                        // Fallback to hardcoded templates if API fails
                        this.worldTemplates = [
                            {
                                id: 'cozy_tavern',
                                name: 'üç∫ Cozy Tavern',
                                description: 'A warm medieval tavern with friendly locals',
                                mood: 'cozy and inviting'
                            },
                            {
                                id: 'anatomical_test_spa',
                                name: 'üíÜ Serenity Spa',
                                description: 'A luxurious spa for relaxation',
                                mood: 'relaxing and intimate'
                            },
                            {
                                id: 'description_test_beach',
                                name: 'üèñÔ∏è Paradise Beach',
                                description: 'A sunny beach resort',
                                mood: 'playful and carefree'
                            },
                            {
                                id: 'custom',
                                name: '‚ú® Custom World',
                                description: 'Create your own setting',
                                mood: 'mysterious'
                            }
                        ];
                    }
                },
                
                async loadSavedCharacters() {
                    try {
                        const response = await fetch('/api/characters/recent?limit=5');
                        if (response.ok) {
                            this.savedCharacters = await response.json();
                        }
                    } catch (error) {
                        console.error('Failed to load saved characters:', error);
                    }
                },
                
                async loadWorldTemplates() {
                    try {
                        const response = await fetch('/api/templates');
                        if (response.ok) {
                            this.worldTemplates = await response.json();
                            console.log('Loaded world templates:', this.worldTemplates);
                        }
                    } catch (error) {
                        console.error('Failed to load world templates:', error);
                    }
                },
                
                loadSavedCharacter(char) {
                    this.character.name = char.name;
                    this.character.description = char.description;
                    // Optionally show a toast or feedback
                    console.log('Loaded character:', char.name);
                },
                
                async saveCharacter() {
                    if (!this.character.name || !this.character.description) return;
                    
                    try {
                        const response = await fetch('/api/characters/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: this.character.name,
                                description: this.character.description
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('Character saved:', result.message);
                            // Reload saved characters list
                            await this.loadSavedCharacters();
                        }
                    } catch (error) {
                        console.error('Failed to save character:', error);
                    }
                },
                
                async resumeSession() {
                    this.gameState = 'loading';
                    
                    try {
                        // Get full session state
                        const response = await fetch(`/api/session/${this.sessionId}/resume`);
                        const data = await response.json();
                        
                        if (data.success) {
                            // Restore character name from data or localStorage
                            const savedName = localStorage.getItem('narrative_character_name');
                            this.character.name = data.player_name || savedName || 'Unknown';
                            
                            // Restore game state
                            this.currentLocation = data.location?.name || 'Unknown';
                            this.locationMood = data.location?.mood || '';
                            this.presentCharacters = data.characters || [];
                            this.tensionLevel = data.tension || 0;
                            
                            // Restore narrative history - ensure each entry has an id
                            if (data.history && Array.isArray(data.history)) {
                                this.narrativeHistory = data.history.map((entry, index) => ({
                                    ...entry,
                                    id: entry.id || `restored-${index}-${Date.now()}`
                                }));
                            } else {
                                this.narrativeHistory = [];
                            }
                            
                            // Get initial narrative from last event if no history
                            if (this.narrativeHistory.length === 0 && data.last_narrative) {
                                this.initialNarrative = data.last_narrative;
                            }
                            
                            this.gameState = 'playing';
                            this.connectWebSocket();
                            
                            // Scroll to bottom
                            this.$nextTick(() => {
                                this.scrollToBottom();
                            });
                        } else {
                            // Failed to resume, start fresh
                            alert('Could not resume your previous session. Please start a new game.');
                            localStorage.removeItem('narrative_session_id');
                            localStorage.removeItem('narrative_character_name');
                            this.sessionId = null;
                            this.gameState = 'character';
                        }
                    } catch (error) {
                        console.error('Failed to resume session:', error);
                        // If resume fails, offer to start fresh
                        if (confirm('Could not resume your previous session. Would you like to start a new adventure?')) {
                            localStorage.removeItem('narrative_session_id');
                            localStorage.removeItem('narrative_character_name');
                            this.sessionId = null;
                            this.gameState = 'character';
                        } else {
                            // Try again
                            window.location.reload();
                        }
                    }
                },
                
                selectWorld(type) {
                    this.character.worldType = type;
                },
                
                async startGame() {
                    if (!this.character.name) return;
                    
                    this.gameState = 'loading';
                    
                    // Auto-save the character if it has a description
                    if (this.character.description) {
                        await this.saveCharacter();
                    }
                    
                    try {
                        const response = await fetch('/api/game/start', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: this.character.name,
                                description: this.character.description || 'A mysterious adventurer',
                                world_type: this.character.worldType,
                                custom_world_prompt: this.character.customPrompt
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.sessionId = data.session_id;
                            
                            // Save session to localStorage
                            localStorage.setItem('narrative_session_id', this.sessionId);
                            localStorage.setItem('narrative_character_name', this.character.name);
                            this.initialNarrative = data.narrative;
                            this.currentLocation = data.location.name || 'Unknown';
                            this.locationMood = data.location.mood || '';
                            
                            // Set world state if provided
                            if (data.world_state) {
                                this.worldState = data.world_state;
                            }
                            
                            // Set up characters
                            this.presentCharacters = [
                                { name: this.character.name, is_player: true, position: 'standing' }
                            ];
                            
                            if (data.characters) {
                                data.characters.forEach(char => {
                                    this.presentCharacters.push({
                                        name: char.name,
                                        is_player: false,
                                        position: char.posture || 'present'
                                    });
                                });
                            }
                            
                            this.gameState = 'playing';
                            this.connectWebSocket();
                            
                            // Scroll to bottom
                            this.$nextTick(() => {
                                this.scrollToBottom();
                            });
                        }
                    } catch (error) {
                        console.error('Failed to start game:', error);
                        alert('Failed to start game. Please try again.');
                        this.gameState = 'character';
                    }
                },
                
                connectWebSocket() {
                    if (!this.sessionId) return;
                    
                    const wsUrl = `ws://${window.location.host}/ws/game/${this.sessionId}`;
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleGameUpdate(data);
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                },
                
                async sendAction() {
                    if (!this.currentAction || this.isProcessing) return;
                    
                    let action = this.currentAction;
                    this.currentAction = '';
                    
                    // Process smart commands
                    if (action.startsWith('/')) {
                        action = this.processSmartCommand(action);
                        if (!action) return; // Command was handled internally
                    }
                    
                    this.isProcessing = true;
                    
                    // Start timing
                    this.processingTime = 0;
                    this.processingRetries = 0;
                    const startTime = Date.now();
                    
                    // Update timer every 100ms
                    this.processingTimer = setInterval(() => {
                        this.processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
                    }, 100);
                    
                    // Handle system commands
                    if (action.toLowerCase() === 'quit') {
                        if (confirm('Save before quitting?')) {
                            await this.saveGame();
                        }
                        window.location.reload();
                        return;
                    }
                    
                    try {
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            // Use WebSocket
                            this.websocket.send(JSON.stringify({ action }));
                        } else {
                            // Fallback to HTTP
                            const response = await fetch('/api/game/action', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    session_id: this.sessionId,
                                    action: action
                                })
                            });
                            
                            const data = await response.json();
                            this.handleGameUpdate({
                                type: 'action_result',
                                narrative: data.narrative,
                                dialogue: data.dialogue,
                                scene: data.scene_updates
                            });
                        }
                        
                        // Add to history - don't initialize dialogue as empty array yet
                        const entryId = Date.now();
                        this.narrativeHistory.push({
                            id: entryId,
                            action: action,
                            narrative: '',
                            dialogue: null  // Start as null, will be set by response
                        });
                        
                    } catch (error) {
                        console.error('Failed to send action:', error);
                    }
                },
                
                handleGameUpdate(data) {
                    console.log('Game update received:', data);
                    
                    if (data.type === 'action_result') {
                        // Update last entry with response
                        if (this.narrativeHistory.length > 0) {
                            const lastEntry = this.narrativeHistory[this.narrativeHistory.length - 1];
                            lastEntry.narrative = data.narrative;
                            lastEntry.dialogue = data.dialogue || [];
                            
                            // Debug log
                            console.log('Updated entry with dialogue:', lastEntry.dialogue);
                        }
                        
                        // Update scene
                        if (data.scene) {
                            if (data.scene.location) {
                                this.currentLocation = data.scene.location.name;
                                this.locationMood = data.scene.location.mood || '';
                            }
                            if (data.scene.characters) {
                                this.presentCharacters = data.scene.characters;
                            }
                            if (data.scene.tension !== undefined) {
                                this.tensionLevel = data.scene.tension;
                            }
                            if (data.scene.world_state) {
                                this.worldState = data.scene.world_state;
                            }
                        }
                        
                        this.isProcessing = false;
                        
                        // Stop timer and record response time
                        if (this.processingTimer) {
                            clearInterval(this.processingTimer);
                            this.processingTimer = null;
                            this.lastResponseTime = parseFloat(this.processingTime);
                        }
                        
                        // Check if this was a retry
                        if (data.error && data.error.includes('retry')) {
                            this.processingRetries++;
                        }
                        
                        this.$nextTick(() => this.scrollToBottom());
                    }
                },
                
                quickAction(action) {
                    this.currentAction = action;
                    this.sendAction();
                },
                
                async saveGame() {
                    const saveName = prompt('Save game as:');
                    if (!saveName) return;
                    
                    try {
                        const response = await fetch(`/api/game/save/${this.sessionId}?save_name=${saveName}`, {
                            method: 'POST'
                        });
                        const data = await response.json();
                        if (data.success) {
                            alert('Game saved!');
                        }
                    } catch (error) {
                        console.error('Failed to save game:', error);
                    }
                },
                
                formatNarrative(text) {
                    // Add some formatting to narrative text
                    return text
                        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                        .replace(/\n/g, '<br>');
                },
                
                scrollToBottom() {
                    const container = document.getElementById('narrative-container');
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                },
                
                processSmartCommand(command) {
                    const parts = command.split(' ');
                    const cmd = parts[0].toLowerCase();
                    const args = parts.slice(1).join(' ');
                    
                    switch(cmd) {
                        case '/help':
                        case '/?':
                            this.showHelp();
                            return null;
                            
                        case '/look':
                        case '/l':
                            if (args) {
                                return `I look at ${args} carefully`;
                            }
                            return 'I look around the room, taking in all the details';
                            
                        case '/examine':
                        case '/x':
                            if (args) {
                                return `I examine ${args} closely`;
                            }
                            return 'I examine my surroundings';
                            
                        case '/whisper':
                        case '/w':
                            const whisperMatch = args.match(/^(\w+)\s+(.+)/);
                            if (whisperMatch) {
                                return `I lean close to ${whisperMatch[1]} and whisper: "${whisperMatch[2]}"`;
                            }
                            return 'I need to specify who to whisper to and what to say';
                            
                        case '/inventory':
                        case '/i':
                            return 'I check my inventory and belongings';
                            
                        case '/stats':
                        case '/s':
                            return 'I reflect on my abilities and condition';
                            
                        case '/seduce':
                            if (args) {
                                return `I attempt to seduce ${args} with my charm`;
                            }
                            return 'I need to specify who to seduce';
                            
                        case '/flirt':
                            if (args) {
                                return `I flirt playfully with ${args}`;
                            }
                            return 'I put on my most charming smile';
                            
                        case '/kiss':
                            if (args) {
                                return `I move in to kiss ${args}`;
                            }
                            return 'I lean in for a kiss';
                            
                        case '/fight':
                        case '/attack':
                            if (args) {
                                return `I attack ${args}!`;
                            }
                            return 'I take an aggressive stance';
                            
                        case '/sneak':
                            return 'I attempt to move stealthily';
                            
                        case '/hide':
                            return 'I try to find a place to hide';
                            
                        case '/pickpocket':
                        case '/steal':
                            if (args) {
                                return `I attempt to pickpocket ${args}`;
                            }
                            return 'I look for an opportunity to steal something';
                            
                        case '/cast':
                            if (args) {
                                return `I cast ${args}`;
                            }
                            return 'I prepare to cast a spell';
                            
                        case '/drink':
                            if (args) {
                                return `I drink ${args}`;
                            }
                            return 'I take a drink';
                            
                        case '/eat':
                            if (args) {
                                return `I eat ${args}`;
                            }
                            return 'I have something to eat';
                            
                        case '/sleep':
                        case '/rest':
                            return 'I find a place to rest';
                            
                        case '/wake':
                            return 'I wake up';
                            
                        case '/time':
                            return 'I check what time it is';
                            
                        case '/weather':
                            return 'I check the weather outside';
                            
                        default:
                            // If not a recognized command, treat as regular text
                            return command;
                    }
                },
                
                showHelp() {
                    const helpText = `
üéÆ SMART COMMANDS:

üìç EXPLORATION:
  /look [at something] - Examine surroundings
  /examine [object] - Detailed examination
  /inventory - Check your items
  /stats - View your abilities
  /time - Check the time
  /weather - Check weather

üí¨ SOCIAL:
  /whisper [name] [message] - Private message
  /seduce [name] - Attempt seduction
  /flirt [name] - Flirt with someone
  /kiss [name] - Attempt a kiss

‚öîÔ∏è ACTION:
  /fight [target] - Start combat
  /sneak - Move stealthily
  /hide - Find hiding spot
  /steal [from] - Attempt theft
  /cast [spell] - Cast magic

üç∫ ACTIVITIES:
  /drink [what] - Have a drink
  /eat [what] - Have food
  /sleep - Rest

Type normally for regular actions!`;
                    
                    // Add help to narrative
                    this.narrativeHistory.push({
                        id: 'help-' + Date.now(),
                        action: '/help',
                        narrative: helpText,
                        dialogue: []
                    });
                    this.scrollToBottom();
                },
                
                testDialogue() {
                    // Add test dialogue to demonstrate it works
                    const testEntry = {
                        id: Date.now(),
                        action: "Test: Greeting Martha",
                        narrative: "You approach the bar with a warm smile.",
                        dialogue: [
                            {
                                speaker: "Martha",
                                dialogue: "Well hello there! Welcome to The Dragon's Rest!",
                                tone: "cheerful"
                            },
                            {
                                speaker: this.character.name || "Player",
                                dialogue: "Thank you! This place looks cozy.",
                                tone: "friendly"
                            },
                            {
                                speaker: "Martha",
                                dialogue: "That it is! What can I get for you?",
                                tone: "inviting"
                            }
                        ]
                    };
                    
                    this.narrativeHistory.push(testEntry);
                    console.log('Added test dialogue:', testEntry);
                    this.$nextTick(() => this.scrollToBottom());
                }
            }
        }
    </script>
    
</body>
</html>